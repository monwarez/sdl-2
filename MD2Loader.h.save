#ifndef MD2LOADER_H_INCLUDED
#define MD2LOADER_H_INCLUDED
#ifdef WIN32
#include <gl/glew.h>
#else
#define GLCOREARB_PROTOTYPES 1
#include <GL/glcorearb.h>
#endif

#include <cstring>
#include <vector>
#include <string>
#include <fstream>
#include <iostream>
#include <memory.h>
#include "Texture.h"
#include "DebugGL.h"

#define NUMVERTEXNORMALS        162
// identifiant "IDP2" ou 844121161
#define MD2_IDENT               (('2'<<24) + ('P'<<16) + ('D'<<8) + 'I')

// numéro de version
#define MD2_VERSION             8

#ifndef BUFFER_OFFSET

    #define BUFFER_OFFSET(offset) ((char*)NULL + (offset))

#endif


// header md2
typedef struct
{
    int ident;          // numéro magique : "IDP2"
    int version;        // version du format : 8

    int skinwidth;      // largeur texture
    int skinheight;     // hauteur texture

    int framesize;      // taille d'une frame en octets

    int num_skins;      // nombre de skins
    int num_vertices;   // nombre de vertices par frame
    int num_st;         // nombre de coordonnées de texture
    int num_tris;       // nombre de triangles
    int num_glcmds;     // nombre de commandes opengl
    int num_frames;     // nombre de frames

    int offset_skins;   // offset données skins
    int offset_st;      // offset données coordonnées de texture
    int offset_tris;    // offset données triangles
    int offset_frames;  // offset données frames
    int offset_glcmds;  // offset données commandes OpenGL
    int offset_end;     // offset fin de fichier

} md2_header_t;
typedef float vec3_t[3];

typedef struct
{
    unsigned char   v[3];
    unsigned char   normalIndex;
}md2_vertex_t;

typedef struct
{
    unsigned short  vertex[3];
    unsigned short  st[3];
}md2_triangle_t;

typedef struct
{
    short           s;
    short           t;
}md2_texCoord_t;

typedef struct
{
    vec3_t          scale;
    vec3_t          translate;
    char            name[16]; // nom  de la frame
    md2_vertex_t    *verts;
}md2_frame_t;
typedef struct
{
    char            name[68];
}md2_skin_t;

// commande OpenGL
typedef struct
{
    float   s;          // coordonnée de texture s
    float   t;          // coordonnée de texture t
    int     index;      // index vertex

} md2_glcmd_t;

class CMD2Model
{
    public:

        CMD2Model();
        CMD2Model(const CMD2Model &model);
        ~CMD2Model();

        bool        LoadModel(std::string szFilename);
        bool        LoadTexture(std::string szFilename);
        void        LoadVBO();
        void        FreeModel();

        void        RenderFrame(int iFrame);
        void        DrawModelItp(int iFrameA, int iFrameB, float fInterp);
        void        RenderFrameWithGLcmds( int iFrame );
        void        DrawModelItpWithGLcmds (int frameA, int frameB, float interp);
        void        SetScale(GLfloat fscale){m_fScale = fscale;};

        GLfloat     GetScaleValue(){return m_fScale;}
        std::string GetModelName(){return m_ModelName;}

    protected:
        void        Update
        static vec3_t           m_kAnorms[NUMVERTEXNORMALS];

        md2_header_t            m_kHeader;      //  header md2
        md2_skin_t              *m_pSkins;      //  données skins
        md2_texCoord_t          *m_pTexCoords;  //  coordonnées de textures
        md2_triangle_t          *m_pTriangles;  //  données triangles
        md2_frame_t             *m_pFrames;     //  données frames
        int                     *m_pGLcmds;     //  liste de commandes openGL

        GLfloat                 m_fScale;       //  redimensionnement du modèle

        Texture                 m_texture;      //  texture

        std::vector<GLfloat>    m_vertice;
        std::vector<GLfloat>    m_texCoord;
        std::vector<GLfloat>    m_normals;

        std::string             m_ModelName;
        GLuint                  m_vboID[3];
        GLuint                  m_vaoID;
        GLuint                  m_sSommets;
        GLuint                  m_sNormals;
        GLuint                  m_sCoord;

        // booléen pour éviter un crash , en effet si on a jamais chargé de modèle , le destructeur ne doit pas être lancé
        bool                    m_isLoadMdl;


};


// Class CEntity
class CEntity
{

    public:
        CEntity();
        ~CEntity() {}


        void    SetModel(CMD2Model *pModel) {m_pModel = pModel;}

        void    DrawEntity(int iFrame , bool bAnimated, bool bUseGLCmds);
        void    Animate(int iStartFrame, int iEndFrame, float fPercent);

        void    SetScale(float fScale) {m_fScale = fScale;}
        float   GetScaleValue(){return m_fScale;}

    protected:
        CMD2Model       *m_pModel;

        int             m_iCurrFrame;
        int             m_iNextFrame;
        float           m_fInterp;          //  pourcentage interpolation

        float           m_fPercent;         //  incrémentation de m_fInterp
        float           m_fScale;


};
#endif // MD2LOADER_H_INCLUDED
